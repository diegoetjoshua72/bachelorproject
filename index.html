<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="./css/index.css">
    <title>λ Kontroli</title>
</head>
<body>
    <h1>
        λ Kontroli
    </h1>
    <div id="container" style="width: 800px; height: 600px; border: 1px solid grey"></div>
    <script src="./monaco/min/vs/loader.js"></script>
    <script>
        require.config({ paths: { vs: './monaco/min/vs' } });

        require(['vs/editor/editor.main'], function () {
            monaco.languages.register({
                id: 'lambdapi'
            });
            monaco.languages.setMonarchTokensProvider('lambdapi', {
                keywords:[],

                tokenizer: {
                    root: [
                        [],
                        [],
                        [],
                        [/&\(\<\h\w*\>\|\({|\([^|]\|\(|[^}]\)\)*|*|}\)\)/,'Constant'],
                        [/?\(\<\h\w*\>\|\({|\([^|]\|\(|[^}]\)\)*|*|}\)\)/,'PreProc'],
                        [/\u\w/,'Type'],
                        [/\(\(\<\h\w*\>\|\({|\([^|]\|\n\|\(|[^}]\)\)*|*|}\)\)\.\)\+\(\<\h\w*\>\|\({|\([^|]\|\n\|\(|[^}]\)\)*|*|}\)\)/, 'Identifier'],
                        [/\(\<\h\w*\>\|\({|\([^|]\|\n\|\(|[^}]\)\)*|*|}\)\)\.\@!/,"Identifier"],
                    ]
                }
            });

            // Define a new theme that constains only rules that match this language
            monaco.editor.defineTheme('vs-gruv', {
                base: 'vs',
                inherit: false,
                rules: [
                    { token: 'custom-info', foreground: '808080' },
                    { token: 'custom-error', foreground: 'ff0000', fontStyle: 'bold' },
                    { token: 'custom-notice', foreground: 'FFA500' },
                    { token: 'custom-date', foreground: '008800' }
                ],
                colors: {
                    [editorBackground]: '#282828',
                    [editorForeground]: '#ebdbb2',

                    [editorInactiveSelection]: '#E5EBF1',
                    [editorIndentGuides]: '#D3D3D3',
                    [editorActiveIndentGuides]: '#939393',
                    [editorSelectionHighlight]: '#689d6a'
	            }
            });

            var editor = monaco.editor.create(document.getElementById('container'), {
                theme: 'vs-gruv',
                value: getCode(),
                language: 'lambdapi'
            });
        });

        function getCode() {
            return [
                    "Typ : Type.",
                    "def eta : _ : Typ -> Type.",

                    "(; theory Pure ;)",
                    "{|fun|type|} : _ : Typ -> _ : Typ -> Typ.",
                    "[a, b] eta ({|fun|type|} a b) --> _ : eta a -> eta b.",
                    "{|prop|type|} : Typ.",
                    "def eps : _ : eta {|prop|type|} -> Type.",
                    "{|itself|type|} : _ : Typ -> Typ.",
                    "{|dummy|type|} : Typ.",
                    "{|Pure.proof|type|} : Typ.",
                    "{|Pure.eq|const|} : {|'a|} : Typ -> eta ({|fun|type|} {|'a|} ({|fun|type|} {|'a|} {|prop|type|})).",
                    "{|Pure.imp|const|} : eta ({|fun|type|} {|prop|type|} ({|fun|type|} {|prop|type|} {|prop|type|})).",
                    "[a, b] eps ({|Pure.imp|const|} a b) --> _ : eps a -> eps b.",
                    "{|Pure.all|const|} : {|'a|} : Typ -> eta ({|fun|type|} ({|fun|type|} {|'a|} {|prop|type|}) {|prop|type|}).",
                    "[a, b] eps ({|Pure.all|const|} a b) --> x : eta a -> eps (b x).",
                    "{|Pure.prop|const|} : eta ({|fun|type|} {|prop|type|} {|prop|type|}).",
                    "{|Pure.type|const|} : {|'a|} : Typ -> eta ({|itself|type|} {|'a|}).",
                    "{|Pure.dummy_pattern|const|} : {|'a|} : Typ -> eta {|'a|}.",
                    "{|Pure.Appt|const|} : {|'a|} : Typ -> eta ({|fun|type|} {|Pure.proof|type|} ({|fun|type|} {|'a|} {|Pure.proof|type|})).'",
                    "{|Pure.AppP|const|} : eta ({|fun|type|} {|Pure.proof|type|} ({|fun|type|} {|Pure.proof|type|} {|Pure.proof|type|})).",
                    "{|Pure.Abst|const|} : {|'a|} : Typ -> eta ({|fun|type|} ({|fun|type|} {|'a|} {|Pure.proof|type|}) {|Pure.proof|type|}).",
                    "{|Pure.AbsP|const|} : eta ({|fun|type|} {|prop|type|} ({|fun|type|} ({|fun|type|} {|Pure.proof|type|} {|Pure.proof|type|}) {|Pure.proof|type|})).'",
                    "{|Pure.Hyp|const|} : eta ({|fun|type|} {|prop|type|} {|Pure.proof|type|}).",
                    "{|Pure.Oracle|const|} : eta ({|fun|type|} {|prop|type|} {|Pure.proof|type|}).",
                    "{|Pure.OfClass|const|} : {|'a|} : Typ -> eta ({|fun|type|} ({|fun|type|} ({|itself|type|} {|'a|}) {|prop|type|}) {|Pure.proof|type|}).",
                    "{|Pure.MinProof|const|} : eta {|Pure.proof|type|}.",
                    "{|Pure.term|const|} : {|'a|} : Typ -> eta ({|fun|type|} {|'a|} {|prop|type|}).",
                    "{|Pure.sort_constraint|const|} : {|'a|} : Typ -> eta ({|fun|type|} ({|itself|type|} {|'a|}) {|prop|type|}).",
                    "{|Pure.conjunction|const|} : eta ({|fun|type|} {|prop|type|} ({|fun|type|} {|prop|type|} {|prop|type|})).",
                    "{|Pure.prop_def|axiom|} : A : eta {|prop|type|} -> eps ({|Pure.eq|const|} {|prop|type|} ({|Pure.prop|const|} A) A).",
            ].join('\n');
        }
    </script>
</body>
</html>